(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{401:function(_,t,v){"use strict";v.r(t);var e=v(42),s=Object(e.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"第11节-动态规划与编辑距离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第11节-动态规划与编辑距离"}},[_._v("#")]),_._v(" 第11节 动态规划与编辑距离")]),_._v(" "),v("p",[_._v("这一节主要学习了：动态规划与编辑距离")]),_._v(" "),v("h3",{attrs:{id:"_1-机器学习的局限"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-机器学习的局限"}},[_._v("#")]),_._v(" 1. 机器学习的局限")]),_._v(" "),v("p",[_._v("如果某个问题存在但不限于以下问题：")]),_._v(" "),v("ol",[v("li",[_._v("缺少数据")]),_._v(" "),v("li",[_._v("缺少标注数据")]),_._v(" "),v("li",[_._v("包含多层推断和决策过程")])]),_._v(" "),v("p",[_._v("那么机器学习较难解决。")]),_._v(" "),v("blockquote",[v("p",[_._v("例如：")]),_._v(" "),v("p",[_._v("背包问题 Knapsack problem、旅行商问题 Travel salesman problem、自动纠错问题 Auto correction")])]),_._v(" "),v("h3",{attrs:{id:"_2-动态规划"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-动态规划"}},[_._v("#")]),_._v(" 2. 动态规划")]),_._v(" "),v("p",[_._v("求解切木头问题：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("长度")]),_._v(" "),v("th",[_._v("1")]),_._v(" "),v("th",[_._v("2")]),_._v(" "),v("th",[_._v("3")]),_._v(" "),v("th",[_._v("4")]),_._v(" "),v("th",[_._v("5")]),_._v(" "),v("th",[_._v("6")]),_._v(" "),v("th",[_._v("7")]),_._v(" "),v("th",[_._v("8")]),_._v(" "),v("th",[_._v("9")]),_._v(" "),v("th",[_._v("10")]),_._v(" "),v("th",[_._v("11")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("价值")]),_._v(" "),v("td",[_._v("1")]),_._v(" "),v("td",[_._v("5")]),_._v(" "),v("td",[_._v("8")]),_._v(" "),v("td",[_._v("9")]),_._v(" "),v("td",[_._v("10")]),_._v(" "),v("td",[_._v("17")]),_._v(" "),v("td",[_._v("17")]),_._v(" "),v("td",[_._v("20")]),_._v(" "),v("td",[_._v("24")]),_._v(" "),v("td",[_._v("30")]),_._v(" "),v("td",[_._v("33")])])])]),_._v(" "),v("p",[_._v("方法1、普通递归")]),_._v(" "),v("p",[_._v("Best_price(N) = max(P_N, Best_price(N-1) + Best_price(1), Best_price(N-2) + Best_price(2), ..., Best_price(1) + Best_price(N))")]),_._v(" "),v("p",[_._v("方法2、带缓存器的递归")]),_._v(" "),v("p",[_._v("要获取最佳价格的时候，先去缓存中查看有没有，有就直接拿，没有才重新计算。")]),_._v(" "),v("p",[v("strong",[_._v("这种在计算时不断把中间过程写入缓存，并且不断从缓存中读取的编程方式，即称为动态编程/动态规划")])]),_._v(" "),v("h3",{attrs:{id:"_3-编辑距离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-编辑距离"}},[_._v("#")]),_._v(" 3. 编辑距离")]),_._v(" "),v("h4",{attrs:{id:"_3-1-编辑距离的思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-编辑距离的思想"}},[_._v("#")]),_._v(" 3.1 编辑距离的思想")]),_._v(" "),v("p",[_._v("两个字符串通过Insertion, Deletion, Substitution的编辑操作，得到的操作步骤最短的步骤数")]),_._v(" "),v("h4",{attrs:{id:"_3-2-编辑距离的算法-动态规划"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-编辑距离的算法-动态规划"}},[_._v("#")]),_._v(" 3.2 编辑距离的算法（动态规划）")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("定义：")])]),_._v(" "),v("p",[_._v("​\t对于2个分别巨有长度m，n的字符串X，Y，")]),_._v(" "),v("p",[_._v("​\t我们定义距离D(i, j)为字串X[0:i], Y[0:j]的编辑距离，")]),_._v(" "),v("p",[_._v("​\t那么X和Y之间的编辑距离就是D(M, N)")]),_._v(" "),v("p",[v("strong",[_._v("初始化：")])]),_._v(" "),v("p",[_._v("​\tD(i, 0) = i")]),_._v(" "),v("p",[_._v("​\tD(0, j) = j")]),_._v(" "),v("p",[v("strong",[_._v("子问题：")])]),_._v(" "),v("p",[_._v("​\t"),v("img",{attrs:{src:"http://latex.codecogs.com/gif.latex?D(i,j)=%5Cmin%5Cbegin%7Bcases%7DD(i-1,j)+1%5CD(i,j-1)+1%5CD(i-1,j-1)+2%5Cquad%7Bif;%7BX(i);%7B!=Y(i)%7D%7D%7D;%7Belse%7D;%7BD(i-1,j-1)%7D%5Cend%7Bcases%7D",alt:""}})])])])}),[],!1,null,null,null);t.default=s.exports}}]);